<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <script src="bower_components/core.js/client/shim.js"></script>
        <script src="bower_components/jasmine-standalone/jasmine-standalone.js"></script>
        <script src="mscrypto-adapter.js"></script>
    </head>
    <body>
        <script>
            function s2b ( s ) {
                s = unescape( encodeURIComponent(s) );
                var b = new Uint8Array(s.length);
                for ( var i = 0; i < s.length; i++ ) {
                    b[i] = s.charCodeAt(i);
                }
                return b;
            }

            function hs2b ( s ) {
                if ( s.length % 2 ) s = '0'+s;
                var b = new Uint8Array(s.length/2);
                for ( var i = 0; i < s.length; i += 2 ) {
                    b[i>>1] = parseInt( s.substr(i,2), 16 );
                }
                return b;
            }

            function b2s ( ab ) {
                var b = new Uint8Array(ab), s = '';
                for ( var i = 0; i < b.length; i++ ) {
                    s += String.fromCharCode( b[i] );
                }
                return decodeURIComponent( escape(s) );
            }

            function b2hs ( ab ) {
                var b = new Uint8Array(ab), s = '';
                for ( var i = 0; i < b.length; i++ ) {
                    var h = b[i].toString(16);
                    if ( h.length < 2 ) s += '0';
                    s += h;
                }
                return s;
            }

            function extend ( o, x ) {
                var r = {};
                for ( var k in o ) r[k] = o[k];
                for ( var k in x ) r[k] = x[k];
                return r;
            }

            describe( 'Util', function () {
                it( 's2b', function () {
                    expect( s2b('') ).toEqual( new Uint8Array() );
                    expect( s2b('a') ).toEqual( new Uint8Array([97]) );
                    expect( s2b("\uD83D\uDE80") ).toEqual( new Uint8Array([0xF0,0x9F,0x9A,0x80]) ); // Unicode ROCKET
                });

                it( 'b2s', function () {
                    expect( b2s( new Uint8Array() ) ).toBe('');
                    expect( b2s(new Uint8Array([97])) ).toBe('a');
                    expect( b2s(new Uint8Array([0xF0,0x9F,0x9A,0x80])) ).toBe("\uD83D\uDE80"); // Unicode ROCKET
                });

                it( 'hs2b', function () {
                    expect( hs2b('') ).toEqual( new Uint8Array() );
                    expect( hs2b('0') ).toEqual( new Uint8Array(1) );
                    expect( hs2b('10203') ).toEqual( new Uint8Array([1,2,3]) );
                });

                it( 'b2hs', function () {
                    expect( b2hs( new ArrayBuffer() ) ).toBe( '' );
                    expect( b2hs( new Uint8Array(1) ) ).toBe( '00' );
                    expect( b2hs( new Uint8Array([1,2,3]) ) ).toBe( '010203' );
                });
            });

            describe( 'window.crypto.subtle', function () {
                it( 'supported', function () {
                    expect( window.crypto ).toBeTruthy();
                    expect( window.crypto.subtle ).toBeTruthy();
                });

                xdescribe( 'SHA-1', function () {
                    var alg = 'SHA-1';

                    xit( 'of empty ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, new ArrayBuffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('da39a3ee5e6b4b0d3255bfef95601890afd80709');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    xit( 'of empty Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, new Uint8Array )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('da39a3ee5e6b4b0d3255bfef95601890afd80709');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!").buffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('2ef7bde608ce5404e97d5f042f95f89f1c232871');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!") )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('2ef7bde608ce5404e97d5f042f95f89f1c232871');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'SHA-256', function () {
                    var alg = 'SHA-256';

                    xit( 'of empty ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, new ArrayBuffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    xit( 'of empty Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, new Uint8Array )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!").buffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!") )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'SHA-384', function () {
                    var alg = 'SHA-384';

                    xit( 'of empty ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, new ArrayBuffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('...');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    xit( 'of empty Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, new Uint8Array )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('...');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!").buffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('bfd76c0ebbd006fee583410547c1887b0292be76d582d96c242d2a792723e3fd6fd061f9d5cfd13b8f961358e6adba4a');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!") )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('bfd76c0ebbd006fee583410547c1887b0292be76d582d96c242d2a792723e3fd6fd061f9d5cfd13b8f961358e6adba4a');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'HMAC_SHA-1', function () {
                    var alg = { name: 'HMAC', hash: 'SHA-1' };

                    it( 'generateKey', function ( done ) {
                        crypto.subtle.generateKey( alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.type).toBe('secret');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from ArrayBuffer and then sign an ArrayBuffer and then verify it', function ( done ) {
                        var secret;

                        crypto.subtle.importKey( 'raw', new ArrayBuffer(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                secret = res;

                                expect(secret).toBeDefined();
                                expect(secret.type).toBe('secret');

                                return crypto.subtle.sign( alg, secret, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('ceda96a7ab5e5703e171081f491ad92f193eb1bf');

                                return crypto.subtle.verify( alg, secret, res, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from Uint8Array and then exportKey', function ( done ) {
                        crypto.subtle.importKey( 'raw', new Uint8Array(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'raw', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('00000000000000');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    xit( 'importKey from JWK and then exportKey to JWK', function ( done ) {
                        crypto.subtle.importKey( 'jwk', { kty: 'oct', k: 'AA' }, alg, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'jwk', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.kty).toBe('oct');
                                expect(res.k).toBe('AA');
                                expect(res.alg).toBe('HS1');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'HMAC_SHA-256', function () {
                    var alg = { name: 'HMAC', hash: 'SHA-256' };

                    it( 'generateKey', function ( done ) {
                        crypto.subtle.generateKey( alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.type).toBe('secret');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from ArrayBuffer and then sign an ArrayBuffer and then verify it', function ( done ) {
                        var secret;

                        crypto.subtle.importKey( 'raw', new ArrayBuffer(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                secret = res;

                                expect(secret).toBeDefined();
                                expect(secret.type).toBe('secret');

                                return crypto.subtle.sign( alg, secret, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('e7655205039eddec669bdc5099863024deef1a609430f10dac5f7889f03bf139');

                                return crypto.subtle.verify( alg, secret, res, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from Uint8Array and then exportKey', function ( done ) {
                        crypto.subtle.importKey( 'raw', new Uint8Array(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'raw', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('00000000000000');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from JWK and then exportKey to JWK', function ( done ) {
                        var jwkKey = {"alg":"HS256","ext":true,"k":"AA","key_ops":["sign","verify"],"kty":"oct"};

                        crypto.subtle.importKey( 'jwk', jwkKey, alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'jwk', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.kty).toBe('oct');
                                expect(res.k).toBe('AA');
                                expect(res.alg).toBe('HS256');
                                expect(res.ext).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'HMAC_SHA-384', function () {
                    var alg = { name: 'HMAC', hash: 'SHA-384' };

                    it( 'generateKey', function ( done ) {
                        crypto.subtle.generateKey( alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.type).toBe('secret');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from ArrayBuffer and then sign an ArrayBuffer and then verify it', function ( done ) {
                        var secret;

                        crypto.subtle.importKey( 'raw', new ArrayBuffer(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                secret = res;

                                expect(secret).toBeDefined();
                                expect(secret.type).toBe('secret');

                                return crypto.subtle.sign( alg, secret, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('3a72e878e1876290d82174c3fdcd877ce9c0f4c19e00c136058e6986e4545eb640ac10cbadfebdf45e3474a02c60060c');

                                return crypto.subtle.verify( alg, secret, res, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from Uint8Array and then exportKey', function ( done ) {
                        crypto.subtle.importKey( 'raw', new Uint8Array(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'raw', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('00000000000000');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from JWK and then exportKey to JWK', function ( done ) {
                        var jwkKey = {
                            "kty":"oct",
                            "alg":"HS384",
                            "k":"AA",
                        };

                        crypto.subtle.importKey( 'jwk', jwkKey, alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof CryptoKey).toBe(true);
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'jwk', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.kty).toBe('oct');
                                expect(res.k).toBe('AA');
                                expect(res.alg).toBe('HS384');
                                expect(res.ext).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'AES-CBC' , function () {
                    var alg = { name: 'AES-CBC', length: 256, tagLength: 128 };
                    var key;

                    var genKeyComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                key = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                expect(key).toBeDefined();
                                expect(key.type).toBe('secret');
                                expect(key.extractable).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( "encrypt and then decrypt", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                return crypto.subtle.encrypt( extend( alg, { iv: new Uint8Array(16) } ), key, new Uint8Array(16) )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);

                                return crypto.subtle.decrypt( extend( alg, { iv: new Uint8Array(16) } ), key, res )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(16);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'AES-GCM' , function () {
                    var alg = { name: 'AES-GCM', length: 256, tagLength: 128 };
                    var key;

                    var genKeyComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                key = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                expect(key).toBeDefined();
                                expect(key.type).toBe('secret');
                                expect(key.extractable).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( "encrypt and then decrypt", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                return crypto.subtle.encrypt( extend( alg, { iv: new Uint8Array(12) } ), key, new Uint8Array(16) )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);

                                return crypto.subtle.decrypt( extend( alg, { iv: new Uint8Array(12) } ), key, res )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(16);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'RSA-OAEP_SHA-1', function () {
                    var alg = { name: 'RSA-OAEP', hash: 'SHA-1', modulusLength: 1024, publicExponent: hs2b('10001') };
                    var keyPair;

                    var genKeyPairComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                keyPair = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyPairComplete
                            .then( function () {
                                expect(keyPair).toBeDefined();
                                expect(keyPair.publicKey).toBeDefined();
                                expect(keyPair.publicKey.type).toBe('public');
                                expect(keyPair.privateKey).toBeDefined();
                                expect(keyPair.privateKey.type).toBe('private');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'encrypt and then decrypt', function ( done ) {
                        genKeyPairComplete
                            .then ( function () {
                                return crypto.subtle.encrypt( alg, keyPair.publicKey, s2b('test') );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(128);
                                return res;
                            })
                            .then ( function ( res ) {
                                return crypto.subtle.decrypt( alg, keyPair.privateKey, res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(4);
                                expect( b2s(res) ).toBe('test');
                                return res;
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'RSA-OAEP_SHA-256', function () {
                    var alg = { name: 'RSA-OAEP', hash: 'SHA-256', modulusLength: 2048, publicExponent: hs2b('10001') };
                    var keyPair;

                    var genKeyPairComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                keyPair = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyPairComplete
                            .then( function () {
                                expect(keyPair).toBeDefined();
                                expect(keyPair.publicKey).toBeDefined();
                                expect(keyPair.publicKey.type).toBe('public');
                                expect(keyPair.privateKey).toBeDefined();
                                expect(keyPair.privateKey.type).toBe('private');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'encrypt and then decrypt', function ( done ) {
                        genKeyPairComplete
                            .then ( function () {
                                return crypto.subtle.encrypt( alg, keyPair.publicKey, s2b('test') );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(256);
                                return res;
                            })
                            .then ( function ( res ) {
                                return crypto.subtle.decrypt( alg, keyPair.privateKey, res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(4);
                                expect( b2s(res) ).toBe('test');
                                return res;
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'exportKey / jwk', function ( done ) {
                        genKeyPairComplete
                            .then ( function () {
                                return crypto.subtle.exportKey( 'jwk', keyPair.privateKey );
                            })
                            .then ( function ( res ) {
                                expect(res).toBeDefined();
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey / jwk', function ( done ) {
                        var jwkKey = {
                            "kty":"RSA",
                            "alg":"RSA-OAEP-256",
                            "n":"zjqltECmgT1Mo925UoACQssXARROi2PjGktxw6NgPVyG3LiSxY4dxGiP5fDjJykkPx8LKIk6k-71Ut5RlcKJQdwyluB7XjNWkx8om7NZ8337fsS8Yp_DBgXMfVI99t34SI0HzHZ_vA2Ang1eKdUQPK7Kq8mD6swS9UQJFzQfecD7Xb46dw4jtJ2lHC4NLqwmHSu8Xf3Q6efOEf53y24_qTptjA-D-gyn51iFuoEssoNdpWxPMP2ExpXz9-Ly2VwHzabNFjAc-cZuK4Tyc_1l3OPbQ82fDi-iSJodzNbpRCbm-d47ai0gROui4iunL2pwM6vooJZA72oxceZGrFGU-w",
                            "e":"AQAB",
                            "d":"awviK1hLlVYeTAixQ3OSuNz2SecihhQJNALpQGWzdOZsUnG0LbuBFAw6dV6-aftfByyz_AyPTW6CBMvFiXj7CiakU9Cd-N2pGKDZ0Ugdbth8DOdN6duHvb6Q0JQ5-cRqNi6OV8FCuHhBxMinkgs4bGdGaDknsl7PkGQKW_MAS4_Cq1e9vGhRDYBhIzw-umzW54YgVAOHhnFLR9WHohZhWzNAlFHAnSz7lV1N4ixt_VJl24GpcbK9d1dSzHi8Jn5cPu7D8SHHlS0KLofqfIfrMshJ3jX_OHnsYTHFdGF3WO36kC1zQxhDQoXR5ege8Dou5x3Yxx_YBWFJ_7HF2v1t0Q",
                            "dp":"FkWoVRH88LGHksR_wFdzirwDzQVCirMiL3AcsfHGZzonYjsI2myK92Ogc1BGwrzB-oZM4WfUdOVJvRSeicI2YuBZFFhFMhVu_7enf_q2lG1HseZ4VhoSishTIt8rwiOUh1pescfN3blKK7abwzeOHol7L-uh7jWPWbiAANwHQEE",
                            "dq":"a7GkVy4ZK6G1iTJvXfGwalXr2wzqGGOaWgMYt25E7hqWWbqsuh35qcONYKCEiXTV2ay3V1D69lc2o5-vxTfMgu2IL36LXGrrKfueFdTPysXOTD_w6qg0e7y7HB6d0MzWHdiOsedwDXSQWDhGR0OulEtLFWrQ-0Ph_3q1oc4cNfk",
                            "p":"_h3jPckueHHAA2Px9DLNd8eZt6sfX86oZ4AvJ91uN6VgGzSMuO5ptn0j9sMfgqcS3W1u32hfaIu0hI_Za7XYSyy-ms0VJCDZuPzBlo-fsbtezgB0y1arW8KU0ncGeejD39yda_dtWXSV-Odf_gIy5qrcw7Dt5fMOOtLLpfk7BV0",
                            "q":"z8HoIiPAaZSkLYPROMQnozV9P9FB9if9VFl7wP6dvQURPm7Kxjy8RJVRv2tBdEUU0TVE91n-ENX9ILEkihwLp9GLNKY6IxKnsHmYYZAX3qTymiKkehXggCzIdC6dZksbXAPVCQ8OS1SnU6ZnvzVdtndrdphEh46kyLlau5McRjc",
                            "qi":"QE5ThOvSdfboEDJ4q64BVn8SPanj3uG2xl5Qh_aJZBAqQgwm2rQ6koyFPCsLIi_pyk5e_l1hslEdpVTDxE7wTs39ZfiLbX73W_4JEbCzr8fjEUKO6-mkpcjTUY_SHVvGIz9tUAPy8N-62YznLMzO_DQdSphHUchPZnXF69a8TvE",
                        };

                        crypto.subtle.importKey( 'jwk', jwkKey, alg, true, [ 'decrypt' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                xdescribe( 'PBKDF2_SHA-1', function () {
                    var alg = { name: 'PBKDF2', hash: 'SHA-1', salt: s2b('the salty salt'), iterations: 4096 };
                    var password;

                    var importPasswordComplete = crypto.subtle.importKey( 'raw', s2b('s3cr3t pa55phra53'), alg, false, [ 'deriveBits', 'deriveKey' ] )
                            .then( function ( res ) {
                                password = res;
                            });

                    it( 'deriveKey', function ( done ) {
                        importPasswordComplete
                            .then( function () {
                                expect(password).toBeDefined();
                                expect(password instanceof CryptoKey).toBe(true);
                                expect(password.type).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .then( function () {
                                return crypto.subtle.deriveKey( alg, password, { name: 'AES-KW', length: 256 }, false, [ 'wrapKey', 'wrapKey' ] );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof CryptoKey ).toBe(true);
                                expect( res.type ).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                xdescribe( 'PBKDF2_SHA-256', function () {
                    var alg = { name: 'PBKDF2', hash: 'SHA-256', salt: s2b('the salty salt'), iterations: 4096 };
                    var password;

                    var importPasswordComplete = crypto.subtle.importKey( 'raw', s2b('s3cr3t pa55phra53'), alg, false, [ 'deriveBits', 'deriveKey' ] )
                            .then( function ( res ) {
                                password = res;
                            });

                    it( 'deriveBits', function ( done ) {
                        importPasswordComplete
                            .then( function () {
                                expect(password).toBeDefined();
                                expect(password instanceof CryptoKey).toBe(true);
                                expect(password.type).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .then( function () {
                                return crypto.subtle.deriveBits( alg, password, 8*32 );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);
                                expect( b2hs(res) ).toBe('7f2c6e2cf0e4d7f7bb38dba02bc3645fe19c83238fa41f51f2e4cc099c0fc0c0');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });
            });
        </script>
    </body>
</html>
