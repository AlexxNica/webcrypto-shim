<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <script src="bower_components/core.js/shim.js"></script>
        <script src="bower_components/jasmine-standalone/jasmine-standalone.js"></script>
        <script src="mscrypto-adapter.js"></script>
    </head>
    <body>
        <script>
            function s2b ( s ) {
                s = unescape( encodeURIComponent(s) );
                var b = new Uint8Array(s.length);
                for ( var i = 0; i < s.length; i++ ) {
                    b[i] = s.charCodeAt(i);
                }
                return b;
            }

            function hs2b ( s ) {
                if ( s.length % 2 ) s = '0'+s;
                var b = new Uint8Array(s.length/2);
                for ( var i = 0; i < s.length; i += 2 ) {
                    b[i>>1] = parseInt( s.substr(i,2), 16 );
                }
                return b;
            }

            function b2s ( ab ) {
                var b = new Uint8Array(ab), s = '';
                for ( var i = 0; i < b.length; i++ ) {
                    s += String.fromCharCode( b[i] );
                }
                return decodeURIComponent( escape(s) );
            }

            function b2hs ( ab ) {
                var b = new Uint8Array(ab), s = '';
                for ( var i = 0; i < b.length; i++ ) {
                    var h = b[i].toString(16);
                    if ( h.length < 2 ) s += '0';
                    s += h;
                }
                return s;
            }

            function extend ( o, x ) {
                var r = {};
                for ( var k in o ) r[k] = o[k];
                for ( var k in x ) r[k] = x[k];
                return r;
            }

            describe( 'Util', function () {
                it( 's2b', function () {
                    expect( s2b('') ).toEqual( new Uint8Array() );
                    expect( s2b('a') ).toEqual( new Uint8Array([97]) );
                    expect( s2b("\uD83D\uDE80") ).toEqual( new Uint8Array([0xF0,0x9F,0x9A,0x80]) ); // Unicode ROCKET
                });

                it( 'b2s', function () {
                    expect( b2s( new Uint8Array() ) ).toBe('');
                    expect( b2s(new Uint8Array([97])) ).toBe('a');
                    expect( b2s(new Uint8Array([0xF0,0x9F,0x9A,0x80])) ).toBe("\uD83D\uDE80"); // Unicode ROCKET
                });

                it( 'hs2b', function () {
                    expect( hs2b('') ).toEqual( new Uint8Array() );
                    expect( hs2b('0') ).toEqual( new Uint8Array(1) );
                    expect( hs2b('10203') ).toEqual( new Uint8Array([1,2,3]) );
                });

                it( 'b2hs', function () {
                    expect( b2hs( new ArrayBuffer() ) ).toBe( '' );
                    expect( b2hs( new Uint8Array(1) ) ).toBe( '00' );
                    expect( b2hs( new Uint8Array([1,2,3]) ) ).toBe( '010203' );
                });
            });

            describe( 'window.crypto.subtle', function () {
                it( 'supported', function () {
                    expect( window.crypto ).toBeTruthy();
                    expect( window.crypto.subtle ).toBeTruthy();
                });

                describe( 'SHA-1', function () {
                    var alg = 'SHA-1';

                    it( 'of empty ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, new ArrayBuffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('da39a3ee5e6b4b0d3255bfef95601890afd80709');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of empty Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, new Uint8Array )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('da39a3ee5e6b4b0d3255bfef95601890afd80709');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!").buffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('2ef7bde608ce5404e97d5f042f95f89f1c232871');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!") )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('2ef7bde608ce5404e97d5f042f95f89f1c232871');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'SHA-256', function () {
                    var alg = 'SHA-256';

                    it( 'of empty ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, new ArrayBuffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of empty Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, new Uint8Array )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" ArrayBuffer', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!").buffer )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'of "Hello World!" Uint8Array', function ( done ) {
                        crypto.subtle.digest( alg, s2b("Hello World!") )
                            .then( function ( res ) {
                                expect( b2hs(res) ).toBe('7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'HMAC_SHA-256', function () {
                    var alg = { name: 'HMAC', hash: 'SHA-256' };

                    it( 'generateKey', function ( done ) {
                        crypto.subtle.generateKey( alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.type).toBe('secret');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from ArrayBuffer and then sign an ArrayBuffer and then verify it', function ( done ) {
                        var secret;

                        crypto.subtle.importKey( 'raw', new ArrayBuffer(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                secret = res;

                                expect(secret).toBeDefined();
                                expect(secret.type).toBe('secret');

                                return crypto.subtle.sign( alg, secret, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('e7655205039eddec669bdc5099863024deef1a609430f10dac5f7889f03bf139');

                                return crypto.subtle.verify( alg, secret, res, new ArrayBuffer(3) );
                            })
                            .then( function ( res ) {
                                expect(res).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'importKey from Uint8Array and then exportKey', function ( done ) {
                        crypto.subtle.importKey( 'raw', new Uint8Array(7), alg, true, [ 'sign', 'verify' ] )
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res.type).toBe('secret');

                                return crypto.subtle.exportKey( 'raw', res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect(res instanceof ArrayBuffer).toBe(true);
                                expect( b2hs(res) ).toBe('00000000000000');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'AES-CBC' , function () {
                    var alg = { name: 'AES-CBC', length: 256, tagLength: 128 };
                    var key;

                    var genKeyComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                key = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                expect(key).toBeDefined();
                                expect(key.type).toBe('secret');
                                expect(key.extractable).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( "encrypt and then decrypt", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                return crypto.subtle.encrypt( extend( alg, { iv: new Uint8Array(16) } ), key, new Uint8Array(16) )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);

                                return crypto.subtle.decrypt( extend( alg, { iv: new Uint8Array(16) } ), key, res )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(16);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'AES-GCM' , function () {
                    var alg = { name: 'AES-GCM', length: 256, tagLength: 128 };
                    var key;

                    var genKeyComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                key = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                expect(key).toBeDefined();
                                expect(key.type).toBe('secret');
                                expect(key.extractable).toBe(true);
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( "encrypt and then decrypt", function ( done ) {
                        genKeyComplete
                            .then( function () {
                                return crypto.subtle.encrypt( extend( alg, { iv: new Uint8Array(12) } ), key, new Uint8Array(16) )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);

                                return crypto.subtle.decrypt( extend( alg, { iv: new Uint8Array(12) } ), key, res )
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(16);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'RSA-OAEP_SHA-1', function () {
                    var alg = { name: 'RSA-OAEP', hash: 'SHA-1', modulusLength: 1024, publicExponent: hs2b('10001') };
                    var keyPair;

                    var genKeyPairComplete = crypto.subtle.generateKey( alg, true, [ 'encrypt', 'decrypt' ] )
                            .then( function ( res ) {
                                keyPair = res;
                            });

                    it( "generateKey", function ( done ) {
                        genKeyPairComplete
                            .then( function () {
                                expect(keyPair).toBeDefined();
                                expect(keyPair.publicKey).toBeDefined();
                                expect(keyPair.publicKey.type).toBe('public');
                                expect(keyPair.privateKey).toBeDefined();
                                expect(keyPair.privateKey.type).toBe('private');
                            })
                            .catch(fail)
                            .then(done);
                    });

                    it( 'encrypt and then decrypt', function ( done ) {
                        genKeyPairComplete
                            .then ( function () {
                                return crypto.subtle.encrypt( alg, keyPair.publicKey, s2b('test') );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(128);
                                return res;
                            })
                            .then ( function ( res ) {
                                return crypto.subtle.decrypt( alg, keyPair.privateKey, res );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(4);
                                expect( b2s(res) ).toBe('test');
                                return res;
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'PBKDF2_SHA-1', function () {
                    var alg = { name: 'PBKDF2', hash: 'SHA-1', salt: s2b('the salty salt'), iterations: 4096 };
                    var password;

                    var importPasswordComplete = crypto.subtle.importKey( 'raw', s2b('s3cr3t pa55phra53'), alg, false, [ 'deriveBits', 'deriveKey' ] )
                            .then( function ( res ) {
                                password = res;
                            });

                    it( 'deriveKey', function ( done ) {
                        importPasswordComplete
                            .then( function () {
                                expect(password).toBeDefined();
                                expect(password instanceof CryptoKey).toBe(true);
                                expect(password.type).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .then( function () {
                                return crypto.subtle.deriveKey( alg, password, { name: 'AES-KW', length: 256 }, false, [ 'wrapKey', 'wrapKey' ] );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof CryptoKey ).toBe(true);
                                expect( res.type ).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .catch(fail)
                            .then(done);
                    });
                });

                describe( 'PBKDF2_SHA-256', function () {
                    var alg = { name: 'PBKDF2', hash: 'SHA-256', salt: s2b('the salty salt'), iterations: 4096 };
                    var password;

                    var importPasswordComplete = crypto.subtle.importKey( 'raw', s2b('s3cr3t pa55phra53'), alg, false, [ 'deriveBits', 'deriveKey' ] )
                            .then( function ( res ) {
                                password = res;
                            });

                    it( 'deriveBits', function ( done ) {
                        importPasswordComplete
                            .then( function () {
                                expect(password).toBeDefined();
                                expect(password instanceof CryptoKey).toBe(true);
                                expect(password.type).toBe('secret');
                                expect(password.extractable).toBe(false);
                            })
                            .then( function () {
                                return crypto.subtle.deriveBits( alg, password, 8*32 );
                            })
                            .then( function ( res ) {
                                expect(res).toBeDefined();
                                expect( res instanceof ArrayBuffer ).toBe(true);
                                expect( res.byteLength ).toBe(32);
                                expect( b2hs(res) ).toBe('7f2c6e2cf0e4d7f7bb38dba02bc3645fe19c83238fa41f51f2e4cc099c0fc0c0');
                            })
                            .catch(fail)
                            .then(done);
                    });
                });
            });
        </script>
    </body>
</html>
